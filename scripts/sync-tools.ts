#!/usr/bin/env node
/**
 * Sync tools from the git submodule (tools/) to src/lib/data.ts
 * This script reads manifest.json from the tools repository and generates
 * the data.ts file with full tool content for the website to render.
 *
 * Usage: tsx scripts/sync-tools.ts
 * Typically run as prebuild step: npm run build
 */

import fs from 'fs/promises';
import path from 'path';

const ROOT_DIR = path.resolve(__dirname, '..');
const TOOLS_DIR = path.join(ROOT_DIR, 'tools');
const MANIFEST_PATH = path.join(TOOLS_DIR, 'manifest.json');
const OUTPUT_PATH = path.join(ROOT_DIR, 'src', 'lib', 'data.ts');

interface HookConfig {
  event: string;
  matcher: string | null;
  command: string;
  type: 'command' | 'prompt';
  timeout: number | null;
}

interface HookRequirements {
  runtime: string[];
  files: string[];
  env: string[];
}

interface HookSetup {
  script?: string;
  description?: string;
}

interface ToolMetadata {
  id: string;
  name: string;
  category: 'hooks' | 'skills' | 'agents' | 'slash-commands' | 'commands' | 'mcp' | 'plugins';
  description: string;
  author: string;
  version: string;
  tags: string[];
  featured?: boolean;
  files?: {
    main: string;
    additional?: string[];
  } | null;
  installation: {
    targetDir?: string; // Optional for categories that only provide a command (e.g., MCP)
    instructions?: string;
  };
  repository?: {
    url?: string;
    stars?: number;
    forks?: number;
  };
  lastUpdated: string;
  downloads?: number;
  rating?: number;
  // Hook-specific fields
  hookConfig?: HookConfig;
  settingsJson?: Record<string, any>;
  requirements?: HookRequirements;
  setup?: HookSetup;
}

interface Manifest {
  version: string;
  generatedAt: string;
  totalTools: number;
  tools: ToolMetadata[];
  categories: {
    hooks: number;
    skills: number;
    agents: number;
    'slash-commands': number;
    commands?: number;
    mcp?: number;
    plugins?: number;
  };
}

interface ToolWithContent extends ToolMetadata {
  content: {
    main: string;
    additional?: Record<string, string>;
  };
}

/**
 * Read file content from the tools repository
 */
async function readToolFile(category: string, toolId: string, fileName: string): Promise<string> {
  const filePath = path.join(TOOLS_DIR, category, toolId, fileName);

  try {
    const content = await fs.readFile(filePath, 'utf-8');
    return content;
  } catch (error) {
    console.warn(`Warning: Could not read ${filePath}`);
    return '';
  }
}

/**
 * Load tool content (main file + additional files)
 */
async function loadToolContent(tool: ToolMetadata): Promise<ToolWithContent> {
  // Some categories (e.g., mcp) may not ship files. Gracefully handle missing files.
  const mainFileName = tool.files?.main;
  const mainContent = mainFileName ? await readToolFile(tool.category, tool.id, mainFileName) : '';

  // Read additional files when defined
  const additionalContent: Record<string, string> = {};
  if (tool.files?.additional) {
    for (const fileName of tool.files.additional) {
      const content = await readToolFile(tool.category, tool.id, fileName);
      additionalContent[fileName] = content;
    }
  }

  return {
    ...tool,
    content: {
      main: mainContent,
      additional: Object.keys(additionalContent).length > 0 ? additionalContent : undefined,
    },
  };
}

/**
 * Generate data.ts file content
 */
function generateDataFileContent(tools: ToolWithContent[]): string {
  // Convert tools to a format suitable for TypeScript
  const toolsJson = JSON.stringify(tools, null, 2);

  return `/**
 * This file is AUTO-GENERATED by scripts/sync-tools.ts
 * DO NOT EDIT MANUALLY
 *
 * Last generated: ${new Date().toISOString()}
 * Source: tools/manifest.json (git submodule)
 */

import { Tool, ToolWithContent } from './types';

export const tools: ToolWithContent[] = ${toolsJson};

// Legacy export for compatibility (without content)
export const toolsBasic: Tool[] = tools.map(tool => {
  const { content, installation, repository, files, hookConfig, settingsJson, requirements, setup, ...basicTool } = tool;
  return basicTool;
});
`;
}

/**
 * Main sync function
 */
async function syncTools(): Promise<void> {
  console.log('Syncing tools from submodule...\n');

  // Check if tools directory exists
  try {
    await fs.access(TOOLS_DIR);
  } catch {
    console.error('Error: tools/ directory not found!');
    console.error('Make sure the git submodule is initialized:');
    console.error('  git submodule update --init --recursive');
    process.exit(1);
  }

  // Check if manifest exists
  try {
    await fs.access(MANIFEST_PATH);
  } catch {
    console.error('Error: tools/manifest.json not found!');
    console.error('Make sure the tools repository has a generated manifest.json');
    process.exit(1);
  }

  // Read manifest
  console.log('Reading manifest.json...');
  const manifestContent = await fs.readFile(MANIFEST_PATH, 'utf-8');
  const manifest: Manifest = JSON.parse(manifestContent);

  console.log(`Found ${manifest.totalTools} tools:`);
  console.log(`  - Hooks: ${manifest.categories.hooks}`);
  console.log(`  - Skills: ${manifest.categories.skills}`);
  console.log(`  - Agents: ${manifest.categories.agents}`);
  console.log(`  - Slash Commands: ${manifest.categories['slash-commands']}`);
  if (manifest.categories.commands !== undefined) {
    console.log(`  - Commands: ${manifest.categories.commands}`);
  }
  if (manifest.categories.mcp !== undefined) {
    console.log(`  - MCP: ${manifest.categories.mcp}`);
  }
  if (manifest.categories.plugins !== undefined) {
    console.log(`  - Plugins: ${manifest.categories.plugins}`);
  }
  console.log('');

  // Load content for each tool
  console.log('Loading tool content...');
  const toolsWithContent: ToolWithContent[] = [];

  for (const tool of manifest.tools) {
    try {
      const toolWithContent = await loadToolContent(tool);
      toolsWithContent.push(toolWithContent);
      console.log(`✓ Loaded ${tool.category}/${tool.id}`);
    } catch (error) {
      console.error(`✗ Failed to load ${tool.category}/${tool.id}:`, error);
      process.exit(1);
    }
  }

  // Generate data.ts file
  console.log('\nGenerating src/lib/data.ts...');
  const fileContent = generateDataFileContent(toolsWithContent);

  // Ensure output directory exists
  const outputDir = path.dirname(OUTPUT_PATH);
  await fs.mkdir(outputDir, { recursive: true });

  // Write file
  await fs.writeFile(OUTPUT_PATH, fileContent, 'utf-8');

  console.log('\n' + '='.repeat(50));
  console.log('✓ Tools synced successfully!');
  console.log('='.repeat(50));
  console.log(`Tools loaded: ${toolsWithContent.length}`);
  console.log(`Output: ${OUTPUT_PATH}`);
  console.log('');
}

// Run the script
syncTools().catch((error) => {
  console.error('\n✗ Error syncing tools:', error);
  process.exit(1);
});
